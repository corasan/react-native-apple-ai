///
/// ToolDefinition.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `ToolDefinition`, backed by a C++ struct.
 */
public typealias ToolDefinition = margelo.nitro.rnappleai.ToolDefinition

public extension ToolDefinition {
  private typealias bridge = margelo.nitro.rnappleai.bridge.swift

  /**
   * Create a new instance of `ToolDefinition`.
   */
  init(name: String, description: String, arguments: AnyMapHolder, handler: @escaping (_ args: AnyMapHolder) -> Promise<Promise<AnyMapHolder>>) {
    self.init(std.string(name), std.string(description), arguments.cppPart, { () -> bridge.Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_ in
      let __closureWrapper = Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_(handler)
      return bridge.create_Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_(__closureWrapper.toUnsafe())
    }())
  }

  var name: String {
    @inline(__always)
    get {
      return String(self.__name)
    }
    @inline(__always)
    set {
      self.__name = std.string(newValue)
    }
  }
  
  var description: String {
    @inline(__always)
    get {
      return String(self.__description)
    }
    @inline(__always)
    set {
      self.__description = std.string(newValue)
    }
  }
  
  var arguments: AnyMapHolder {
    @inline(__always)
    get {
      return AnyMapHolder(withCppPart: self.__arguments)
    }
    @inline(__always)
    set {
      self.__arguments = newValue.cppPart
    }
  }
  
  var handler: (_ args: AnyMapHolder) -> Promise<Promise<AnyMapHolder>> {
    @inline(__always)
    get {
      return { () -> (AnyMapHolder) -> Promise<Promise<AnyMapHolder>> in
        let __wrappedFunction = bridge.wrap_Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_(self.__handler)
        return { (__args: AnyMapHolder) -> Promise<Promise<AnyMapHolder>> in
          let __result = __wrappedFunction.call(__args.cppPart)
          return { () -> Promise<Promise<AnyMapHolder>> in
            let __promise = Promise<Promise<AnyMapHolder>>()
            let __resolver = { (__result: Promise<AnyMapHolder>) in
              __promise.resolve(withResult: __result)
            }
            let __rejecter = { (__error: Error) in
              __promise.reject(withError: __error)
            }
            let __resolverCpp = { () -> bridge.Func_void_std__shared_ptr_Promise_std__shared_ptr_AnyMap___ in
              let __closureWrapper = Func_void_std__shared_ptr_Promise_std__shared_ptr_AnyMap___(__resolver)
              return bridge.create_Func_void_std__shared_ptr_Promise_std__shared_ptr_AnyMap___(__closureWrapper.toUnsafe())
            }()
            let __rejecterCpp = { () -> bridge.Func_void_std__exception_ptr in
              let __closureWrapper = Func_void_std__exception_ptr(__rejecter)
              return bridge.create_Func_void_std__exception_ptr(__closureWrapper.toUnsafe())
            }()
            let __promiseHolder = bridge.wrap_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap_____(__result)
            __promiseHolder.addOnResolvedListener(__resolverCpp)
            __promiseHolder.addOnRejectedListener(__rejecterCpp)
            return __promise
          }()
        }
      }()
    }
    @inline(__always)
    set {
      self.__handler = { () -> bridge.Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_ in
        let __closureWrapper = Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_(newValue)
        return bridge.create_Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_AnyMap______std__shared_ptr_AnyMap_(__closureWrapper.toUnsafe())
      }()
    }
  }
}
